name: YouTube Downloader Windows
on:
  workflow_dispatch:
    inputs:
      video_url:
        description: 'YouTube URL'
        required: true
        default: 'https://www.youtube.com/watch?v=kKgt_azwT0M'
      resolution:
        description: 'Resolution'
        required: true
        type: choice
        default: '1440'
        options: ['720', '1080', '1440']
      trim_enabled:
        description: 'Enable Trim?'
        type: boolean
        default: true
      start_time:
        description: 'Start (00:00:00)'
        default: '00:00:00'
      end_time:
        description: 'End (00:00:10)'
        default: '00:00:40'
      hls_split_enabled:
        description: 'Enable HLS Splitting?'
        type: boolean
        default: true
      hls_max_mb:
        description: 'Max HLS segment size (MB)'
        required: true
        default: '15'
      aes_key:
        description: 'AES Encryption Key (leave empty to skip)'
        required: false
        default: ''
      manual_cookies:
        description: 'Paste Netscape Cookies here'
        required: false

jobs:
  download:
    runs-on: windows-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
      
      - name: Setup FFmpeg & FFprobe
        uses: AnimMouse/setup-ffmpeg@v1

      - name: Setup yt-dlp
        uses: AnimMouse/setup-yt-dlp@v3
        with:
          # We set this to false because we just installed FFmpeg manually above
          ffmpeg: false
      - name: Process and Validate Cookies
        shell: bash
        env:
          RAW_COOKIES: ${{ github.event.inputs.manual_cookies }}
        run: |
          if [[ -n "$RAW_COOKIES" ]]; then
            # 'tr -d' removes Windows carriage returns that break the cookie file
            echo "$RAW_COOKIES" | tr -d '\r' > cookies.txt
            
            if grep -q "Netscape" cookies.txt && grep -q "youtube.com" cookies.txt; then
              echo "✅ Cookie file is valid Netscape format."
              echo "USE_COOKIES=true" >> $GITHUB_ENV
            else
              echo "❌ ERROR: Invalid cookie format."
              exit 1
            fi
          else
            echo "⚠️ No cookies provided."
            echo "USE_COOKIES=false" >> $GITHUB_ENV
          fi

      - name: Install & Start Cloudflare WARP
        shell: powershell
        run: |
          # Установка через winget (доступно на windows-latest)
          winget install --id Cloudflare.Warp --silent --accept-package-agreements --accept-source-agreements
          # Запуск сервиса (может занять время)
          Start-Process "C:\Program Files\Cloudflare\Cloudflare WARP\warp-svc.exe"
          Start-Sleep -s 10
          & "C:\Program Files\Cloudflare\Cloudflare WARP\warp-cli.exe" --accept-tos registration new
          & "C:\Program Files\Cloudflare\Cloudflare WARP\warp-cli.exe" --accept-tos connect

#      - name: Check Available Formats
#        shell: bash
#        run: |
#          COOKIE_ARG=""
#          if [[ "$USE_COOKIES" == "true" ]]; then
#            COOKIE_ARG="--cookies cookies.txt"
#          fi
#          
#          echo "--- AVAILABLE FORMATS FOR THIS VIDEO ---"
#          yt-dlp $COOKIE_ARG \
#            --user-agent "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/122.0.0.0 Safari/537.36" \
#            --extractor-args "youtube:player_client=android_vr,tv" \
#            -F "${{ github.event.inputs.video_url }}"
#          echo "----------------------------------------"

      - name: Run Download
        shell: bash
        env:
          AES_KEY: ${{ github.event.inputs.aes_key }}
        run: |
          COOKIE_ARG=""
          if [[ "$USE_COOKIES" == "true" ]]; then
            COOKIE_ARG="--cookies cookies.txt"
          fi

          TRIM_ARG=""
          if [[ "${{ github.event.inputs.trim_enabled }}" == "true" ]]; then
            TRIM_ARG="--download-sections *${{ github.event.inputs.start_time }}-${{ github.event.inputs.end_time }}"
          fi

          # 1. Принудительно выводим сообщение, чтобы проверить, работают ли логи
          echo ">>> STARTING DOWNLOAD PROCESS <<<"
          
          # Мы используем клиент 'tv', так как он чаще всего отдает HD без PO Token.
          # Селектор "bestvideo[height<=?1440]+bestaudio/best" наиболее универсален.
          yt-dlp --verbose \
            $COOKIE_ARG \
            $TRIM_ARG \
            --user-agent "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/122.0.0.0 Safari/537.36" \
            --extractor-args "youtube:player_client=android_vr,tv;player_skip=configs" \
            --no-cache-dir \
            --fixup force \
            --write-thumbnail \
            --convert-thumbnails jpg \
            --print-to-file "{\"title\": \"%(title)s\", \"resolution\": \"${{ github.event.inputs.resolution }}p\", \"url\": \"%(webpage_url)s\", \"id\": \"%(id)s\", \"format_note\": \"%(format_note)s\"}" metadata.json \
            -f "bestvideo[height<=${{ github.event.inputs.resolution }}]+bestaudio/best[height<=${{ github.event.inputs.resolution }}]" \
            --merge-output-format mp4 \
            -o "video.mp4" \
            "${{ github.event.inputs.video_url }}"           

          echo ">>> DIRECTORY CONTENT <<<"
          ls -1R

          # --- HLS SPLIT LOGIC ---
          if [[ "${{ github.event.inputs.hls_split_enabled }}" == "true" ]]; then
            echo ">>> STARTING HLS SPLIT (fMP4 for AV1 Support) <<<"
            # 1. Создаем папку (явно)
            mkdir -p output
            
            # 1. Получаем битрейт видео через ffprobe
            # В некоторых MP4 битрейт может быть не в streams, а в format (bit_rate)
            # 1. Get bitrate (removing the problematic 'nocontrol_characters' flag)
            BITRATE=$(ffprobe -v error -select_streams v:0 -show_entries stream=bit_rate -of default=noprint_wrappers=1 video.mp4 | cut -d'=' -f2 | tr -d '\r')

            # 2. Fallback to format bitrate if stream bitrate is empty
            if [[ -z "$BITRATE" || "$BITRATE" == "N/A" ]]; then
              BITRATE=$(ffprobe -v error -show_entries format=bit_rate -of default=noprint_wrappers=1 video.mp4 | cut -d'=' -f2 | tr -d '\r')
            fi

            # 2. Логика определения HLS_TIME
            if [[ -z "$BITRATE" || "$BITRATE" == "N/A" || "$BITRATE" -eq 0 ]]; then
              echo "⚠️ Не удалось определить битрейт. Используем HLS_TIME=10"
              HLS_TIME=10
            else
              # Считаем через bash (целочисленное деление)
              # Формула: (Лимит_МБ * 8 * 1024 * 1024 * 0.9) / BITRATE
              # Для точности в bash сначала умножаем на 90, потом делим на 100
              LIMIT_MB=${{ github.event.inputs.hls_max_mb }}
              
              # Считаем числитель (МБ в биты с запасом 10% на аудио/заголовки)
              BITS_LIMIT=$(( LIMIT_MB * 8 * 1024 * 1024 ))
              SAFE_BITS=$(( BITS_LIMIT * 90 / 100 ))
              
              HLS_TIME=$(( SAFE_BITS / BITRATE ))
              
              # Защита от слишком маленьких или больших значений
              [[ "$HLS_TIME" -lt 2 ]] && HLS_TIME=2
              [[ "$HLS_TIME" -gt 60 ]] && HLS_TIME=60
              
              echo "✅ Определенный битрейт: $BITRATE bps"
              echo "✅ Рассчитанное время: $HLS_TIME сек (для лимита $LIMIT_MB MB)"
            fi

            # Initialize encryption flags as empty
            ENC_FLAGS=""
        
            if [ -n "$AES_KEY" ]; then
              echo "Key found, configuring encryption..."
              # Create the actual key file
              echo -n "$AES_KEY" > output/enc.key
              # Create the key info file (1st line: URI, 2nd line: Path)
              echo "enc.key" > key_info.txt
              echo "output/enc.key" >> key_info.txt
              ENC_FLAGS="-hls_key_info_file key_info.txt"
            fi

            LIMIT_MB=${{ github.event.inputs.hls_max_mb }} * 1024 * 1024
            # 3. Запускаем FFmpeg с поддержкой AV1 (fmp4) и исправленными путями
            # Используем -c copy для сохранения оригинального качества и битрейта
            ffmpeg -i video.mp4 \
              -c:v libx265 -preset slow -crf 32 -vtag hvc1 \
              -pix_fmt yuv420p \
              -c:a aac -b:a 64k \
              -start_number 1 \
              -hls_list_size 0 \
              -hls_max_seg_size "$MAX_SIZE" \
              -hls_segment_type mpegts \
              -hls_segment_filename "output/data_%03d" \
              $ENC_FLAGS \
              -f hls output/playlist.m3u8

            # Настройки
            VIDEO_ID="lesson_1"
            REPO_PATH="user/repo@main/folder"
            START_NUM=100
            
            # 1. Извлекаем длительности из плейлиста в формате 10.1,9.8,10.2
            DURATIONS=$(grep "#EXTINF:" output/playlist.m3u8 | sed 's/#EXTINF:\([^,]*\),/\1/' | tr '\n' ',' | sed 's/,$//')
            
            # 2. Модифицируем metadata.json через sed
            # Мы удаляем закрывающую скобку '}' и вставляем массив сегментов
            sed -i "s/}$/,\"segments\": [$DURATIONS]}/" metadata.json
            
            echo "✅ Metadata updated with segments info"
            echo ">>> DIRECTORY CONTENT <<<"
            ls -1R
          else
            echo ">>> HLS Split disabled, skipping... <<<"
          fi
          
          cat metadata.json

      - name: Upload Artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: youtube-package
          path: |
            video.mp4
            video.jpg
            metadata.json
            assets.json
            output/
          retention-days: 1

      - name: Delete old workflow runs
        uses: Mattraks/delete-workflow-runs@v2
        with:
          token: ${{ github.token }}
          repository: ${{ github.repository }}
          retain_days: 0 # удаляет запуски любой давности
          keep_minimum_runs: 3  # Оставить только 3 последних запуска

